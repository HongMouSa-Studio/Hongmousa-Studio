-- ==========================================
-- 1. DATABASE SETUP (Fixes Trigger Error)
-- ==========================================

-- PROFILES TABLE
CREATE TABLE IF NOT EXISTS public.profiles (
  id UUID REFERENCES auth.users NOT NULL PRIMARY KEY,
  display_name TEXT,
  phone TEXT,
  contact_email TEXT,
  points INTEGER DEFAULT 0,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

-- Drop and Recreate Policies for Profiles
DROP POLICY IF EXISTS "Users can view own profile" ON public.profiles;
CREATE POLICY "Users can view own profile" ON public.profiles FOR SELECT USING (auth.uid() = id);

DROP POLICY IF EXISTS "Users can update own profile" ON public.profiles;
CREATE POLICY "Users can update own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

-- ADDRESS BOOK TABLE
CREATE TABLE IF NOT EXISTS public.address_book (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users NOT NULL,
  recipient_name TEXT NOT NULL,
  address TEXT NOT NULL,
  is_default BOOLEAN DEFAULT false,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

ALTER TABLE public.address_book ENABLE ROW LEVEL SECURITY;

-- Drop and Recreate Policies for Address Book
DROP POLICY IF EXISTS "Users can view own addresses" ON public.address_book;
CREATE POLICY "Users can view own addresses" ON public.address_book FOR SELECT USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can insert own addresses" ON public.address_book;
CREATE POLICY "Users can insert own addresses" ON public.address_book FOR INSERT WITH CHECK (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can update own addresses" ON public.address_book;
CREATE POLICY "Users can update own addresses" ON public.address_book FOR UPDATE USING (auth.uid() = user_id);

DROP POLICY IF EXISTS "Users can delete own addresses" ON public.address_book;
CREATE POLICY "Users can delete own addresses" ON public.address_book FOR DELETE USING (auth.uid() = user_id);

-- ORDERS TABLE
CREATE TABLE IF NOT EXISTS public.orders (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID REFERENCES auth.users NOT NULL,
  snipcart_id TEXT UNIQUE NOT NULL,
  total_price NUMERIC(10, 2) NOT NULL,
  status TEXT NOT NULL,
  items JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL
);

ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;

-- Drop and Recreate Policies for Orders
DROP POLICY IF EXISTS "Users can view own orders" ON public.orders;
CREATE POLICY "Users can view own orders" ON public.orders FOR SELECT USING (auth.uid() = user_id);

-- TRIGGERS & FUNCTIONS
-- Handle updated_at
CREATE OR REPLACE FUNCTION public.handle_updated_at() RETURNS TRIGGER AS $$ BEGIN NEW.updated_at = NOW(); RETURN NEW; END; $$ LANGUAGE plpgsql;
DROP TRIGGER IF EXISTS on_profile_update ON public.profiles;
CREATE TRIGGER on_profile_update BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

-- Handle new user signup (auto-create profile)
CREATE OR REPLACE FUNCTION public.handle_new_user() RETURNS TRIGGER AS $$ BEGIN INSERT INTO public.profiles (id, contact_email) VALUES (NEW.id, NEW.email) ON CONFLICT (id) DO NOTHING; RETURN NEW; END; $$ LANGUAGE plpgsql;

-- CORRECTED TRIGGER DROP
DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created AFTER INSERT ON auth.users FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- ==========================================
-- 2. TESTING (Optional)
-- ==========================================
-- Run these after getting your UUID from auth.users:
-- INSERT INTO public.orders (user_id, snipcart_id, total_price, status, created_at) VALUES ('YOUR_ID_HERE', 'TEST_001', 500.00, 'COMPLETED', NOW());
-- INSERT INTO public.address_book (user_id, recipient_name, address, is_default) VALUES ('YOUR_ID_HERE', 'A-it', 'Ko-hiông-chhī...', true);
